<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="screen-orientation" content="landscape">
    <title>å®‹å®‹ç”Ÿæ—¥å¿«ä¹å‘€ğŸ‘»</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Montserrat:wght@300;700&display=swap');

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #050505;
            font-family: 'Montserrat', sans-serif;
        }

        /* æ¨ªå±æç¤ºé®ç½© */
        #rotate-screen {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Ma Shan Zheng', cursive;
            transition: opacity 0.5s ease;
        }

        #rotate-screen .rotate-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }

        #rotate-screen .rotate-text {
            font-size: 1.5rem;
            letter-spacing: 2px;
            margin-bottom: 30px;
        }

        /* è·³è¿‡/ç»§ç»­æŒ‰é’®æ ·å¼ */
        #skip-rotate-btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Ma Shan Zheng', cursive;
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd700 100%);
            border: none;
            border-radius: 50px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        #skip-rotate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 107, 107, 0.6);
        }

        #skip-rotate-btn:active {
            transform: scale(0.98);
        }

        /* ç§»åŠ¨ç«¯ç«–å±æ—¶æ˜¾ç¤ºæç¤º */
        @media screen and (max-width: 900px) and (orientation: portrait) {
            #rotate-screen {
                display: flex;
            }
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
            opacity: 0; transition: opacity 1s ease-out;
            will-change: opacity;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }

        /* å¯åŠ¨é¡µ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.9); z-index: 100;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            pointer-events: auto; transition: opacity 0.8s ease-out;
            will-change: opacity;
        }

        .gift-icon {
            font-size: 80px; cursor: pointer;
            animation: bounce 1.5s infinite;
            filter: drop-shadow(0 0 20px rgba(255, 51, 102, 0.5));
        }

        .click-hint {
            margin-top: 20px; color: #fff;
            font-size: clamp(1rem, 3vw, 1.5rem);
            opacity: 0.8; letter-spacing: 2px;
            font-family: 'Ma Shan Zheng', cursive;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        /* é¡¶éƒ¨æ ‡é¢˜ - å›ºå®šé‡‘è‰² + å“åº”å¼å­—ä½“ */
        .header-text {
            position: absolute; width: 100%; top: 12%;
            font-size: clamp(1.5rem, 5vw, 3.5rem);
            font-weight: bold;
            color: #ffd700;
            background: none;
            text-shadow:
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 215, 0, 0.6),
                    0 0 30px rgba(255, 193, 7, 0.4),
                    0 0 40px rgba(255, 215, 0, 0.3);
            opacity: 0; transition: opacity 1s;
            text-align: center;
            font-family: 'Ma Shan Zheng', cursive;
            letter-spacing: clamp(2px, 1vw, 8px);
            user-select: none;
            caret-color: transparent;
            outline: none;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* é›ªèŠ±æ ·å¼ */
        .snowflake {
            position: fixed;
            color: #fff;
            font-size: 1rem;
            top: -20px;
            z-index: 150;
            pointer-events: none;
            opacity: 0.8;
            animation: snowfall linear infinite;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }

        @keyframes snowfall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.8;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0.3;
            }
        }

        /* å½©å¸¦/ç¤¼èŠ±æ ·å¼ */
        .confetti {
            position: fixed;
            z-index: 180;
            pointer-events: none;
            font-size: 14px;
        }

        .confetti.left {
            animation: confettiLeft var(--duration, 3s) cubic-bezier(0.12, 0.8, 0.4, 1) forwards;
        }

        .confetti.right {
            animation: confettiRight var(--duration, 3s) cubic-bezier(0.12, 0.8, 0.4, 1) forwards;
        }

        @keyframes confettiLeft {
            0% {
                opacity: 1;
                transform: translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(var(--endX, 150px), var(--endY, 300px)) rotate(var(--rotate, 720deg));
            }
        }

        @keyframes confettiRight {
            0% {
                opacity: 1;
                transform: translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(var(--endX, -150px), var(--endY, 300px)) rotate(var(--rotate, -720deg));
            }
        }

        /* æˆå°±å¼¹çª— - å“åº”å¼ */
        .achievement-popup {
            position: absolute;
            left: 50%; transform: translateX(-50%);
            top: -100px; opacity: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(255, 215, 0, 0.8);
            color: #ffd700;
            padding: clamp(10px, 2.5vw, 15px) clamp(25px, 5vw, 45px);
            border-radius: 15px;
            font-size: clamp(0.9rem, 2.5vw, 1.3rem);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), inset 0 0 20px rgba(255, 215, 0, 0.1);
            white-space: nowrap;
            font-family: 'Ma Shan Zheng', cursive;
            transition: top 1s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 1s ease;
            z-index: 200;
            user-select: none;
            caret-color: transparent;
            outline: none;
        }
        .achievement-popup.show { top: 4%; opacity: 1; }

        /* æˆå°±å›ºå®šåœ¨é¡¶éƒ¨å±…ä¸­çš„æ ·å¼ */
        .achievement-popup.pinned {
            left: 50%;
            top: 15px !important;
            transform: translateX(-50%);
            opacity: 1 !important;
            font-size: clamp(0.8rem, 2.2vw, 1.1rem);
            padding: clamp(8px, 2vw, 12px) clamp(18px, 4vw, 30px);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .achievement-popup.pinned:hover {
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6), inset 0 0 25px rgba(255, 215, 0, 0.15);
        }

        /* å¥–æ¯å›¾æ ‡æŒ‰é’® */
        #trophy-btn {
            position: absolute;
            left: 15px;
            top: 15px;
            font-size: clamp(1.5rem, 4vw, 2rem);
            cursor: pointer;
            z-index: 200;
            opacity: 0;
            transition: all 0.5s ease;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));
            pointer-events: auto;
            display: none;
        }
        #trophy-btn:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.9));
        }
        #trophy-btn.show {
            opacity: 1;
            display: block;
        }

        /* ç•™è¨€æ¿ - å“åº”å¼ */
        #message-board {
            position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 85%; max-width: 500px;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: clamp(20px, 4vw, 40px);
            color: #fff;
            font-size: clamp(1rem, 2.5vw, 1.4rem);
            line-height: 1.8;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            font-family: 'Ma Shan Zheng', cursive;
            text-align: center;
            cursor: pointer;
            box-sizing: border-box;
        }

        /* ä¾¿ç­¾æ ·å¼ - ç«–å±æ‰‹æœºä¼˜åŒ– */
        #message-board.sticky-note {
            left: 46%;
            right: auto;
            top: 70%;
            bottom: auto;
            transform: translateX(-50%) rotate(-15deg) !important;
    /* è°ƒæ•´å®½åº¦é€»è¾‘ï¼šæ‰‹æœºä¸å°äº200ï¼Œç”µè„‘ä¸å¤§äº300 */
    width: clamp(200px, 48vw, 300px);
    padding: clamp(15px, 4vw, 25px);

    background: linear-gradient(145deg, #fff9c4 0%, #fff59d 50%, #ffee58 100%);
    box-shadow: 8px 8px 20px rgba(0,0,0,0.35);
    color: #5d4037;
    font-size: clamp(0.9rem, 3vw, 1.1rem);
    line-height: 1.4;
    text-align: left;
    z-index: 9;

    /* ç¡®ä¿æ ·å¼ç”Ÿæ•ˆ */
    position: absolute;
    right: auto;
    bottom: auto;
    border: none;
        }
        #message-board.sticky-note::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 18px;
            background: linear-gradient(180deg, rgba(180, 180, 180, 0.9), rgba(150, 150, 150, 0.8));
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #message-board.sticky-note::after {
            content: 'ğŸ“Œ';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
        }

        /* ç…§ç‰‡å±•ç¤ºæ ·å¼ - ä¹¦é¡µé‡å æ•ˆæœ */
        #photo-card {
            position: absolute;
            left: 52%;
            top: 70%;
            transform: translateX(calc(-50% + 80px)) rotate(15deg);
            height: auto;
            padding: clamp(12px, 3vw, 18px);
            background: linear-gradient(145deg, #f5f5f5 0%, #e8e8e8 50%, #d0d0d0 100%);
            border: none;
            box-shadow:
                8px 8px 20px rgba(0,0,0,0.35),
                -2px -2px 8px rgba(255,255,255,0.5),
                inset 0 0 30px rgba(245, 245, 245, 0.5);
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
            display: none;
            cursor: pointer;
            box-sizing: border-box;
            z-index: 10;
        }

        #photo-card.show {
            display: block;
            opacity: 1;
        }

        #photo-card.expanded {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(0deg) !important;
            height: auto;
            padding: 12px 12px 35px 12px; /* åº•éƒ¨ç•™ç™½åƒæ‹ç«‹å¾— */
            background: #fff;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.4);

            opacity: 0;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: auto;
            display: none;
            cursor: pointer;
            z-index: 8; /* é»˜è®¤åœ¨ä¾¿ç­¾ä¸‹é¢ */
        }


        /* ä¿®æ”¹åŸæœ‰çš„å›¾ç‰‡æ ·å¼ */
        #photo-card img {
            /* å…³é”®ä¿®æ”¹ï¼šæœ€å°å€¼è®¾ä¸º 120pxï¼Œä¿è¯æ‰‹æœºä¸Šä¸ä¼šå¤ªå° */
            height: clamp(120px, 15vw, 220px);
            width: auto;
            border-radius: 2px;
            display: block;
            object-fit: cover;
        }

        #photo-card::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 18px;
            background: linear-gradient(180deg, rgba(180, 180, 180, 0.9), rgba(150, 150, 150, 0.8));
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #photo-card::after {
            content: 'ğŸ“';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
        }

        #photo-card img {
            height: clamp(67px, 36vw, 220px);
            width: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: block;
        }

        #photo-card .photo-caption {
            display: none;
        }

        </style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <!-- é›ªèŠ±æ•ˆæœè„šæœ¬ - ç«‹å³æ‰§è¡Œ -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const snowflakeChars = ['â„', 'â…', 'â†', 'âœ¦', 'âœ§', 'â€¢'];

            function createSnowflake() {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                snowflake.textContent = snowflakeChars[Math.floor(Math.random() * snowflakeChars.length)];
                snowflake.style.left = Math.random() * 100 + 'vw';
                snowflake.style.fontSize = (Math.random() * 0.8 + 0.5) + 'rem';
                snowflake.style.opacity = Math.random() * 0.5 + 0.3;
                const duration = Math.random() * 5 + 5;
                snowflake.style.animationDuration = duration + 's';
                document.body.appendChild(snowflake);

                setTimeout(() => {
                    if(snowflake.parentNode) {
                        snowflake.parentNode.removeChild(snowflake);
                    }
                }, duration * 1000);
            }

            setInterval(createSnowflake, 200);
            for(let i = 0; i < 15; i++) {
                setTimeout(createSnowflake, i * 50);
            }
        });
    </script>
</head>
<body>

<!-- æ¨ªå±æç¤º -->
<div id="rotate-screen">
    <div class="rotate-icon">ğŸ’»</div>
    <div class="rotate-text">ç”µè„‘æ‰“å¼€æ•ˆæœæ›´ä½³</div>
    <button id="skip-rotate-btn">ç»§ç»­è®¿é—®</button>
</div>

<div id="start-screen">
    <div class="gift-icon">ğŸ</div>
    <div class="click-hint">ç‚¹å‡»æ‰“å¼€å“Ÿ</div>
</div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="header" class="header-text">å®‹å®‹ç”Ÿæ—¥å¿«ä¹å‘€</div>
    <div id="trophy-btn">ğŸ†</div>
    <div id="achievement" class="achievement-popup">ğŸ†è§£é”æˆå°±ï¼š"21å²å•¦ï¼"</div>
    <div id="message-board"></div>
    <div id="photo-card">
        <img src="together.jpg" alt="ç”Ÿæ—¥åˆç…§">
        <div class="photo-caption">ğŸ’ ç¾å¥½çš„å›å¿† ğŸ’</div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import TWEEN from 'three/addons/libs/tween.module.js';

    const CONFIG = {
        particleCount: 7500,
        colors: {
            nebulaCore: 0xffaa00,
            nebulaEdge: 0x0000ff,
            cakeCore: 0xffe4b5,
            cakeEdge: 0xff6b6b,
            candleWax: 0xffffff,
            flame: 0xffd700
        },
        bloomStrength: 1.5
    };

    let stage = 0;
    let isTransitioning = false;
    let flameSprites = [];
    let messageMinimized = false;

    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    const isPortrait = window.innerHeight > window.innerWidth;
    camera.position.set(0, 3, isPortrait ? 32 : 19);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.autoRotate = false;

    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = CONFIG.bloomStrength;
    bloomPass.radius = 0.4;

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);
    const sizes = new Float32Array(CONFIG.particleCount);

    for (let i = 0; i < CONFIG.particleCount; i++) {
        positions[i*3] = (Math.random()-0.5)*100;
        positions[i*3+1] = (Math.random()-0.5)*100;
        positions[i*3+2] = (Math.random()-0.5)*100;
        sizes[i] = 0;
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    function createSparkTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.5)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }

    const particleTexture = createSparkTexture();

    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            pointTexture: { value: particleTexture },
            uTime: { value: 0 },
            uMouse: { value: new THREE.Vector3(9999, 9999, 9999) },
            uInteractionRadius: { value: 4.0 },
            uGlobalSize: { value: 1.0 }
        },
        vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                uniform float uTime;
                uniform vec3 uMouse;
                uniform float uInteractionRadius;
                uniform float uGlobalSize;
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    float dist = distance(pos, uMouse);
                    if (dist < uInteractionRadius) {
                        vec3 dir = normalize(pos - uMouse);
                        float force = (uInteractionRadius - dist) * 1.5;
                        pos += dir * force;
                    }
                    pos.y += sin(uTime * 1.5 + pos.x * 0.5) * 0.05;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * uGlobalSize * (250.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
        fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                    if (gl_FragColor.a < 0.1) discard;
                }
            `,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        transparent: true
    });

    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);

    let preloadedNebulaData = null;

    function getRGB(hex) {
        const c = new THREE.Color(hex);
        return [c.r, c.g, c.b];
    }

    function createFlameTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');

        ctx.beginPath();
        ctx.moveTo(32, 60);
        ctx.bezierCurveTo(10, 50, 10, 10, 32, 2);
        ctx.bezierCurveTo(54, 10, 54, 50, 32, 60);

        const grd = ctx.createRadialGradient(32,40,5, 32,40,30);
        grd.addColorStop(0, '#fff');
        grd.addColorStop(0.3, '#ffaa00');
        grd.addColorStop(0.7, '#ff0000');
        grd.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = grd;
        ctx.fill();
        return new THREE.CanvasTexture(canvas);
    }

    function generateNebulaShape() {
        const arr = [];
        const cols = [];
        const coreCol = getRGB(CONFIG.colors.nebulaCore);
        const edgeCol = getRGB(CONFIG.colors.nebulaEdge);
        const isPortrait = window.innerHeight > window.innerWidth;
        const maxRadius = isPortrait ? 8 : 14;
        for(let i=0; i<CONFIG.particleCount; i++) {
            const r = Math.pow(Math.random(), 2.5) * maxRadius;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            arr.push(r * Math.sin(phi) * Math.cos(theta));
            arr.push(r * Math.sin(phi) * Math.sin(theta));
            arr.push(r * Math.cos(phi));

            const t = r / maxRadius;
            cols.push(coreCol[0]*(1-t)+edgeCol[0]*t, coreCol[1]*(1-t)+edgeCol[1]*t, coreCol[2]*(1-t)+edgeCol[2]*t);
        }
        return { positions: arr, colors: cols };
    }

    function generateCakeShape() {
        const arr = [];
        const cols = [];
        const coreCol = getRGB(CONFIG.colors.cakeCore);
        const edgeCol = getRGB(CONFIG.colors.cakeEdge);
        const waxCol = getRGB(CONFIG.colors.candleWax);

        const numCount = 1800;
        const cakeCount = CONFIG.particleCount - numCount;

        const bottomLayerCount = Math.floor(cakeCount * 0.5);
        for(let i=0; i<bottomLayerCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 2.8 + Math.random() * 1.2;
            const height = Math.random() * 1.8 - 1.8;

            const r = Math.random() > 0.3 ? radius : Math.random() * 3.5;

            arr.push(r * Math.cos(angle), height, r * Math.sin(angle));

            const dist = r / 4.0;
            const t = Math.min(dist, 1.0);
            cols.push(
                coreCol[0]*(1-t)+edgeCol[0]*t,
                coreCol[1]*(1-t)+edgeCol[1]*t,
                coreCol[2]*(1-t)+edgeCol[2]*t
            );
        }

        const topLayerCount = Math.floor(cakeCount * 0.35);
        for(let i=0; i<topLayerCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.8 + Math.random() * 0.8;
            const height = Math.random() * 1.2;

            const r = Math.random() > 0.3 ? radius : Math.random() * 2.2;

            arr.push(r * Math.cos(angle), height, r * Math.sin(angle));

            const dist = r / 2.5;
            const t = Math.min(dist, 1.0);
            cols.push(
                coreCol[0]*(1-t)+edgeCol[0]*t,
                coreCol[1]*(1-t)+edgeCol[1]*t,
                coreCol[2]*(1-t)+edgeCol[2]*t
            );
        }

        const decorCount = cakeCount - bottomLayerCount - topLayerCount;
        for(let i=0; i<decorCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const isBottomEdge = Math.random() > 0.5;
            let r, y;
            if(isBottomEdge) {
                r = 3.8 + Math.random() * 0.3;
                y = -0.1 + Math.random() * 0.2;
            } else {
                r = 2.4 + Math.random() * 0.3;
                y = 1.1 + Math.random() * 0.2;
            }

            arr.push(r * Math.cos(angle), y, r * Math.sin(angle));
            cols.push(
                coreCol[0]*0.8+edgeCol[0]*0.2,
                coreCol[1]*0.8+edgeCol[1]*0.2,
                coreCol[2]*0.8+edgeCol[2]*0.2
            );
        }

        const textPoints = getTextPoints("21");
        for(let i=0; i<numCount; i++) {
            const p = textPoints[i % textPoints.length];
            const x = p.x * 0.025;
            const y = p.y * 0.025 + 1.8;
            const z = (Math.random()-0.5)*0.25;
            arr.push(x, y, z);
            cols.push(...waxCol);
        }
        return { positions: arr, colors: cols };
    }

    function getTextPoints(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 100; canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 80px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 50, 50);
        const data = ctx.getImageData(0,0,100,100).data;
        const points = [];
        for(let y=0; y<100; y+=2) {
            for(let x=0; x<100; x+=2) {
                if(data[(y*100+x)*4 + 3] > 128) points.push({x: x-50, y: -(y-50)});
            }
        }
        return points;
    }

    function generateLitCakeState() {
        const currentPos = particleGeometry.attributes.position.array;
        const currentCols = particleGeometry.attributes.color.array;

        const newPos = [];
        const newCols = [];

        for(let i=0; i < CONFIG.particleCount; i++) {
            let x = currentPos[i*3];
            let y = currentPos[i*3+1];
            let z = currentPos[i*3+2];
            let r = currentCols[i*3];
            let g = currentCols[i*3+1];
            let b = currentCols[i*3+2];

            newPos.push(x, y, z);
            newCols.push(r, g, b);
        }
        return { positions: newPos, colors: newCols };
    }

    document.getElementById('start-screen').addEventListener('click', function() {
        this.style.opacity = '0';
        setTimeout(() => {
            requestAnimationFrame(() => {
                this.style.display = 'none';
                enterNebulaStage();
            });
        }, 800);
    });

    window.addEventListener('click', onCanvasClick);

    function enterNebulaStage() {
        document.getElementById('canvas-container').style.opacity = '1';
        const sizes = particleGeometry.attributes.size.array;
        for(let i=0; i<sizes.length; i++) sizes[i] = Math.random();
        particleGeometry.attributes.size.needsUpdate = true;

        applyShapeImmediate(preloadedNebulaData);

        scene.scale.set(0.1, 0.1, 0.1);
        new TWEEN.Tween(scene.scale).to({x:1, y:1, z:1}, 1500).easing(TWEEN.Easing.Elastic.Out).start();

        stage = 1;
    }

    function onCanvasClick(e) {
        if (e.target.closest('.gift-icon') || e.target.closest('#start-screen')) return;
        if (isTransitioning || stage === 0) return;

        if (stage === 1) {
            isTransitioning = true;
            const cakeData = generateCakeShape();
            transitionParticles(cakeData, 2000);

            new TWEEN.Tween(particleMaterial.uniforms.uGlobalSize).to({value: 0.8}, 2000).start();
            new TWEEN.Tween(bloomPass).to({strength: 0.8, radius: 0.3}, 2000).start();

            setTimeout(() => {
                document.getElementById('header').style.opacity = 1;
                stage = 2;
                isTransitioning = false;
            }, 2000);

        } else if (stage === 2) {
            isTransitioning = true;
            const litData = generateLitCakeState();
            transitionParticles(litData, 500);

            const map = createFlameTexture();

            const material1 = new THREE.SpriteMaterial({ map: map, blending: THREE.AdditiveBlending });
            const flame1 = new THREE.Sprite(material1);
            flame1.position.set(-0.65, 3.3, 0);
            flame1.scale.set(0, 0, 1);
            scene.add(flame1);
            flameSprites.push(flame1);

            const material2 = new THREE.SpriteMaterial({ map: map, blending: THREE.AdditiveBlending });
            const flame2 = new THREE.Sprite(material2);
            flame2.position.set(0.65, 3.3, 0);
            flame2.scale.set(0, 0, 1);
            scene.add(flame2);
            flameSprites.push(flame2);

            flameSprites.forEach((flame, idx) => {
                new TWEEN.Tween(flame.scale)
                    .to({x: 0.5, y: 0.7, z: 1}, 800)
                    .delay(idx * 100)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
            });

            new TWEEN.Tween(bloomPass).to({ strength: 2.5 }, 200).yoyo(true).repeat(1).to({ strength: 1.2 }, 1000).start();

            launchConfetti();

            const ach = document.getElementById('achievement');
            ach.classList.add('show');
            setTimeout(() => {
                ach.classList.remove('show');
                const trophyBtn = document.getElementById('trophy-btn');
                trophyBtn.classList.add('show');
            }, 5000);

            stage = 3;
            isTransitioning = false;

        } else if (stage === 3) {
            stage = 4;
            const msgBoard = document.getElementById('message-board');
            msgBoard.style.display = 'block';
            void msgBoard.offsetWidth;
            msgBoard.style.opacity = '1';
            msgBoard.style.transform = 'translate(-50%, -50%) scale(1)';
            const text = "ğŸ‚Toå®‹å®‹ï¼š\n\nç”Ÿæ—¥å¿«ä¹å‘€ï¼\nä¸–ç•Œè¾½é˜”ï¼Œç¥ä½ é—ªé—ªå‘å…‰ï¼Œ\näººç”Ÿæµ·æµ·ï¼Œç¥ä½ ä¸€å¸†é£é¡ºã€‚\n21å²ï¼Œç²¾å½©æ‰åˆšåˆšå¼€å§‹ï¼\n\nBest Wishes. âœ¨";
            let i = 0;
            msgBoard.innerHTML = "";
            const typeWriter = () => {
                if (i < text.length) {
                    msgBoard.innerHTML += text.charAt(i) === '\n' ? '<br/>' : text.charAt(i);
                    i++;
                    setTimeout(typeWriter, 50);
                }
            };
            typeWriter();
        } else if (stage === 4) {
            const msgBoard = document.getElementById('message-board');
            msgBoard.classList.add('sticky-note');
            messageMinimized = true;

            setTimeout(() => {
                const photoCard = document.getElementById('photo-card');
                photoCard.classList.add('show');
            }, 500);

            stage = 5;
        } else if (stage === 5 && e.target.closest('#message-board')) {
            const msgBoard = document.getElementById('message-board');
            const photoCard = document.getElementById('photo-card');
            msgBoard.classList.remove('sticky-note');
            photoCard.classList.remove('show');
            photoCard.classList.remove('expanded');
            messageMinimized = false;
            stage = 4;
        } else if (stage === 5 && e.target.closest('#photo-card')) {
            const photoCard = document.getElementById('photo-card');
            photoCard.classList.toggle('expanded');
        }
    }

    document.getElementById('skip-rotate-btn').addEventListener('click', function() {
        const rotateScreen = document.getElementById('rotate-screen');
        rotateScreen.style.opacity = '0';
        setTimeout(() => {
            rotateScreen.style.display = 'none';
        }, 500);
    });

    let achievementPinned = false;
    document.getElementById('trophy-btn').addEventListener('click', function(e) {
        e.stopPropagation();
        const ach = document.getElementById('achievement');
        const trophyBtn = document.getElementById('trophy-btn');

        if (!achievementPinned) {
            ach.classList.add('pinned');
            ach.classList.add('show');
            trophyBtn.classList.remove('show');
            achievementPinned = true;
        }
    });

    document.getElementById('achievement').addEventListener('click', function(e) {
        if (achievementPinned) {
            e.stopPropagation();
            const ach = document.getElementById('achievement');
            const trophyBtn = document.getElementById('trophy-btn');

            ach.classList.remove('pinned');
            ach.classList.remove('show');
            trophyBtn.classList.add('show');
            achievementPinned = false;
        }
    });

    function launchConfetti() {
        const colors = ['#ff1744', '#ff6f00', '#ffd600', '#00e5ff', '#f50057', '#d500f9', '#00e676', '#ffd700', '#ff4081', '#7c4dff'];
        const confettiShapes = ['â–®', 'â—', 'â—†', 'â˜…', 'â™¥', 'âœ¦', 'â– ', 'â–²', 'â™¦'];
        const startY = window.innerHeight * 0.2;

        for (let i = 0; i < 40; i++) {
            setTimeout(() => createConfettiPiece('left', colors, confettiShapes, startY), i * 12);
        }
        for (let i = 0; i < 40; i++) {
            setTimeout(() => createConfettiPiece('right', colors, confettiShapes, startY), i * 12);
        }
    }

    function createConfettiPiece(side, colors, shapes, startY) {
        const confetti = document.createElement('div');
        confetti.className = `confetti ${side}`;
        confetti.textContent = shapes[Math.floor(Math.random() * shapes.length)];
        confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.fontSize = `${Math.random() * 14 + 10}px`;

        if (side === 'left') {
            confetti.style.left = '0px';
        } else {
            confetti.style.right = '0px';
        }
        confetti.style.top = `${startY}px`;

        const direction = side === 'left' ? 1 : -1;
        const endX = (Math.random() * 200 + 100) * direction;
        const endY = Math.random() * 350 + 250;
        const rotate = (Math.random() * 720 + 360) * direction;
        const duration = 2.5 + Math.random() * 1.5;

        confetti.style.setProperty('--endX', `${endX}px`);
        confetti.style.setProperty('--endY', `${endY}px`);
        confetti.style.setProperty('--rotate', `${rotate}deg`);
        confetti.style.setProperty('--duration', `${duration}s`);

        document.body.appendChild(confetti);

        setTimeout(() => {
            if (confetti.parentNode) {
                confetti.parentNode.removeChild(confetti);
            }
        }, duration * 1000 + 300);
    }

    function applyShapeImmediate(shape) {
        const posAttr = particleGeometry.attributes.position;
        const colAttr = particleGeometry.attributes.color;
        for(let i=0; i<CONFIG.particleCount; i++) {
            posAttr.array[i*3] = shape.positions[i*3];
            posAttr.array[i*3+1] = shape.positions[i*3+1];
            posAttr.array[i*3+2] = shape.positions[i*3+2];
            colAttr.array[i*3] = shape.colors[i*3];
            colAttr.array[i*3+1] = shape.colors[i*3+1];
            colAttr.array[i*3+2] = shape.colors[i*3+2];
        }
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
    }

    function transitionParticles(targetShape, duration) {
        const posAttr = particleGeometry.attributes.position;
        const colAttr = particleGeometry.attributes.color;
        const startPositions = Float32Array.from(posAttr.array);
        const startColors = Float32Array.from(colAttr.array);
        const obj = { t: 0 };
        new TWEEN.Tween(obj)
            .to({ t: 1 }, duration)
            .easing(TWEEN.Easing.Quintic.InOut)
            .onUpdate(() => {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const idx = i * 3;
                    posAttr.array[idx] = startPositions[idx] * (1-obj.t) + targetShape.positions[idx] * obj.t;
                    posAttr.array[idx+1] = startPositions[idx+1] * (1-obj.t) + targetShape.positions[idx+1] * obj.t;
                    posAttr.array[idx+2] = startPositions[idx+2] * (1-obj.t) + targetShape.positions[idx+2] * obj.t;

                    if(targetShape.colors) {
                        colAttr.array[idx] = startColors[idx] * (1-obj.t) + targetShape.colors[idx] * obj.t;
                        colAttr.array[idx+1] = startColors[idx+1] * (1-obj.t) + targetShape.colors[idx+1] * obj.t;
                        colAttr.array[idx+2] = startColors[idx+2] * (1-obj.t) + targetShape.colors[idx+2] * obj.t;
                    }
                }
                posAttr.needsUpdate = true;
                if(targetShape.colors) colAttr.needsUpdate = true;
            }).start();
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(9999, 9999);
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

    function updateMousePosition(clientX, clientY) {
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const target = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, target);
        particleMaterial.uniforms.uMouse.value.copy(target);
    }

    window.addEventListener('mousemove', (e) => {
        updateMousePosition(e.clientX, e.clientY);
    });

    window.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
            const touch = e.touches[0];
            updateMousePosition(touch.clientX, touch.clientY);
        }
    }, { passive: true });

    window.addEventListener('touchend', () => {
        particleMaterial.uniforms.uMouse.value.set(9999, 9999, 9999);
    });

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update();
        controls.update();
        flameSprites.forEach((flame, idx) => {
            flame.material.rotation = Math.sin(time*0.005 + idx)*0.15;
            const scaleBase = 0.5;
            flame.scale.set(
                scaleBase + Math.sin(time*0.012 + idx*0.5)*0.05,
                scaleBase*1.4 + Math.cos(time*0.012 + idx*0.5)*0.06,
                1
            );
        });
        particleMaterial.uniforms.uTime.value = time * 0.001;
        composer.render();
    }

    preloadedNebulaData = generateNebulaShape();

    for(let i = 0; i < 3; i++) {
        composer.render();
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);

        const isPortrait = window.innerHeight > window.innerWidth;
        camera.position.z = isPortrait ? 32 : 19;
    });
</script>
</body>
</html>
